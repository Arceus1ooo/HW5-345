# Reflection ([Discord Reward Bot](https://github.com/KennethSkelton/SSW345TeamProject))
<br>

### Design
1. Referencing our UML diagrams and group brainstorming became the most useful methods of determining the design methods of our project. We relied mostly on the class diagrams, as we used an object-oriented approach for the development of our reward bot. We also used our sequence flow diagram to determine how the objects interacted with each other.
2. The biggest obstacle during our brainstorming and coding sessions was figuring out the microinteractions between the user and the bot. We already knew how the bot and related objects were going to be designed, but we spent lots of time discussing and figuring out exactly how the bot interacted with the user. To solve this, we could have made the sequence flow diagrams differently. If we made more specific diagrams that described the microinteractions between the user and the bot, this would not have been an issue.
3. Besides UML diagrams and group brainstorming, I would like to incorporate user testing in the development of the bot. While we were developing the bot, we ran into problms with the prompting of the user. It became complicated very quickly. If we conducted user testing, we could have gotten insight on how to better prompt the user while interacting with the bot.
<br>

### Implementation
1. Creating a Discord server for testing the bot was the most helpful thing for implementing, testing, and integrating our bot. Instead of posting ideas in a group chat, we could brainstorm right where the bot was being tested. Furthermore, with an actual server, we could conduct more realistic tests since the bot was in its intended environment. We could also prove consistent progess on the bot as chat logs with the bot are automatically saved during testing, so everyone could see the progress of the bot in real time.
2. The biggest obstacle while implementing our bot was learning how the Discord API behaved. Our reward bot relied on asynchronous functions, and that made bug fixing difficult because it was hard to pinpont the flow of the code. To reduce the impact of this problem, it would have been a good idea to utilize pair programming more. I found it difficult to understand the asynchronous behavior on my own, but we would tackle problems much more quickly during group coding sessions.
3. I would utilize pair programming again for a similar project. With a dedicated Discord server for testing the bot, one team member can interact with the bot while another team member is adding more logic and functionality. This would streamline development, and if any bugs or learning curves were to arise, the other team members in the coding session could lend a hand, resolving problems faster.
<br>

### Process
1.  Implementing kanban into our project helped the most when it came to delegating and remembering tasks. In my previous experiences with group projects, development moved much slower when tasks and work delegation operated via word by mouth. Kanban allowed us to keep track of all of the project tasks while assigning them to members such that everyone had equal load. Code review software was also most helpful when it came to coding convention. Looking between files was much easier when they had the same coding convention(s).
2.  Since we did not have to limit ourselves to tasks that we could remember, the greatest difficulty while using kanban was accomplishing all of the tasks. Looking back at the project, we created too many tasks, and we had to remove some due to time and experience constraints. The biggest difficulty with code review is that even when it was implemented into the project, some members didn't follow the conventions that were defined by the software. So, it was time consuming to analyze every script and fix convention errors when the team members could have followed the conventions from the start.
3.  In future GitHub projects, I would like to use kanban again. It is a great tool to keep track of the project's tasks, as well as who is doing what. Especially with larger projects with larger groups, it is very difficult to keep track of the progress made without a tool like kanban. Progress in a project is also satisfying with kanban because the UI is laid out in a start-to-finish orientation.
<br>

### Overall
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Considering design methods, since we took an object-oriented approach to the project, using class diagrams proved to be much more useful than any other UML diagram. Although we were diligent in drawing out a storyboard, that time could have been put to much better use improving the sequence flow diagrams because the storyboard did not allow efficient project progress. Class and sequence flow diagrams are useful when paired together because the class diagrams is the layout of object and object-object interactions, while the sequence flow diagrams are the layout of user-system interactions.
Considering implementation practices, the benefits of the Discord server outweigh the benefits from pair programming. Having a dedicated testing environment was very helpul, and in most cases needed, while developing the bot. Without a Discord testing environment for the Discord bot, the development of the reward would have been impossible. Analyzing the benefits of combining the dedicated testing environment with pair programming, it is exponentially higher than the testing environment alone. We found that when using the combination effectively, the progress made by the group was much greater than the sum of the individual progress of each team member developing alone.
Considering the external interfaces used in the project, kanban and code review cannot easily be compared. In fact, we could have developed the project just as well without code review. After developing the bot, the code review software hindered us more than it helped, and independently defined a coding convention rather than relying on software. Kanban, on the other hand, was very helpful, and only hindered us due to our fault of creating too many tasks.
